import json
import os
from collections import OrderedDict
from typing import List, Union

from qiskit_metal import Dict
from qiskit_metal.renderers.renderer_palace.palace_materials import PalaceMaterial 

class PalaceConfig:
    """
    Class for generating the config file (JSON) for simulation settings on Palace.

    Use various properties and methods to change the settings.
    Then call self.write_config_json to create the JSON file.  
    """

    __supported_problem_type__ = ["Eigenmode", 
                                  "Driven", 
                                  "Transient", 
                                  "Electrostatic", 
                                  "Magnetostatic"]

    __supported_boundary_conditions__ = ["PEC",
                                         "Impedance",
                                         "Absorbing",
                                         "Conductivity",
                                         "LumpedPort",
                                         "WavePort",
                                         "WavePortPEC",
                                         "SurfaceCurrent",
                                         "Ground",
                                         "ZeroCharge",
                                         "Terminal"]
    
    def __init__(self):
        self.Problem = Dict()
        self.Model = Dict()
        self.Domains = Dict()
        self.Boundaries = Dict()
        self.Solver = Dict()
        self._config = Dict()
        self._materials = OrderedDict()
    
    @property
    def config(self):
        self._config = Dict(Problem=self.Problem,
                            Model=self.Model,
                            Domains=self.Domains,
                            Boundaries=self.Boundaries,
                            Solver=self.Solver)
        return self._config


    ##### self.Problem #####
    ## self.Problem.Type ##
    @property
    def problem_type(self):
        return self.Problem.Type
    
    @problem_type.setter
    def problem_type(self, problem_type: str):
        """Add supported simulation type.
        
        Args:
            problem_type (str): Simulation type. Accepted values are in self.__supported_problem_type__.
        """
        if problem_type in self.__supported_problem_type__:
            self.Problem.Type = problem_type
        else:
            raise ValueError(f"problem_type must be one of the following: {self.__supported_problem_type__}")
    
    ## self.Problem.Verbose ##
    @property
    def log_verboseness(self):
        return self.Problem.Verbose
    
    @log_verboseness.setter
    def log_verboseness(self, value: int):
        """Set printing log verboseness

        Args:
            value (int): Printing log verboseness.
        """
        self.Problem.Verbose = int(value)

    ## self.Problem.Output ##
    @property
    def output_path(self, path: str):
        return self.Problem.Output
    
    @output_path.setter
    def output_path(self, output_path: str):
        """Set path of output files from simulation
        """
        self.Problem.Output = str(output_path)


    ##### self.Model #####
    ## self.Model.Mesh ##
    @property
    def mesh_path(self):
        return self.Model.Mesh
    
    @mesh_path.setter
    def mesh_path(self, path: str):
        """Set path to mesh generated by GMSH, absolute path is recommended."""
        self.Model.Mesh = str(path)

    ##### self.Domains #####
    @property
    def materials(self):
        return self._materials

    def assign_material(self, 
                     name: str, 
                     attributes: list[int], 
                     permeability: float, 
                     permittivity: float, 
                     loss_tan: float, 
                     conductivity: float, 
                     london_depth: float, 
                     material_axes: list):
        """Method to add a new material / update existing materials.
        """
        palace_material = PalaceMaterial(name, 
                                  attributes, 
                                  permeability, 
                                  permittivity, 
                                  loss_tan, 
                                  conductivity, 
                                  london_depth, 
                                  material_axes)
        package = palace_material.dict_for_json()

        # Updates self.materials property
        self._materials[name] = palace_material

        # Updates self.Domains.Materials
        if name in self._materials:
            pos = list(self._materials.keys()).index(name)
            self.Domains.Materials[pos] = package
        else:
            self.Domains.setdefault("Materials", []).append(package)


    ##### self.Boundaries #####
    def add_pec(self, attributes: list[int]):
        """Add a Perfect Electrical Conductor (PEC) boundary condition)"""
        self.Boundaries.setdefault("PEC", {"Attributes": []})["Attributes"] += attributes
    
    def add_conductivity(self, 
                         attributes: list[int], 
                         conductivity: float,
                         permeability: float,
                         thickness: float = None):
        """
        Add a Conductor boundary condition
        
        Args:
            attributes (list[int]): Integer array of mesh boundary attributes for this finite conductivity boundary.
            conductivity (float): Electrical conductivity for this finite conductivity boundary, S/m.
            permeability (float): Relative permeability for this finite conductivity boundary.
            thickness (float, optional): Conductor thickness for this finite conductivity boundary specified in mesh length units. 
                                         Activates a finite conductivity boundary condition which accounts for nonzero metal thickness.
                                         Defaults to infinitesimally thin. 
        """
        package = Dict(Attributes=attributes,
                       Conductivity=conductivity,
                       Permeability=permeability,
                       Thickness=thickness)
        self.Boundaries.setdefault("Conductivity", []).append(package)

    def add_lumped_port(self, 
                        index: int,
                        attributes: list[int],
                        direction: str,
                        excitation: bool,
                        R: float = 0.0,
                        L: float = 0.0,
                        C: float = 0.0,
                        per_square: bool = False):
        """
        Add a Lumped Port boundary condition.

        Args:
            Index (int): Index of this lumped port, used in postprocessing output files.
            Attributes (list[int]): Integer array of mesh boundary attributes for this lumped port boundary. 
                            If this port is to be a multielement lumped port with more than a single lumped element, 
                            use the "Elements" array described below.
            Direction (str): Direction to define the polarization direction of the port field mode on this lumped port boundary. 
                            Lumped ports must be axis-aligned unless the port is a coaxial port. 
                            The available options are: "+X", "-X", "+Y", "-Y", "+Z", "-Z", "+R", "-R" ("R" is for a coaxial lumped port). 
                            If this port is to be a multielement lumped port with more than a 
                            single lumped element, use the "Elements" array described below.
            Excitation (bool): Turns on or off port excitation for this lumped port boundary for driven or transient simulation types.
            R (float, optional): Circuit resistance used for computing this lumped port boundary's impedance, Ω. Defaults to 0 Ω.
            L (float, optional): Circuit inductance used for computing this lumped port boundary's impedance, H. Defaults to 0 H.
            C (float, optional): Circuit capacitance used for computing this lumped port boundary's impedance, F. Defaults to 0 F.
            per_square (bool, optional): Change `R`, `L`, `C` units to unit / sq. Defaults to false (off).
        """
        # Check for valid directions
        supported_directions = ["+X", "-X", "+Y", "-Y", "+Z", "-Z", "+R", "-R"]
        if direction not in supported_directions:
            raise ValueError(f'direction must be one of the following: {supported_directions}')
        
        # Begin applying Lumped Port
        package = Dict(Index=index,
                       Attributes=attributes,
                       Direction=direction,
                       Excitation=excitation)
        # Check wether units are in per_square or not.
        if (bool(per_square) == False):
            package['R'] = R
            package['L'] = L
            package['C'] = C
        else:
            package['Rs'] = R
            package['Ls'] = L
            package['Cs'] = C
        
        self.Boundaries.setdefault("LumpedPort", []).append(package)

    def add_ground(self, attributes: list[int]):
        self.Boundaries.setdefault("Ground", {"Attributes": []})["Attributes"] += attributes

    def add_dielectric(self, 
                       index: int, 
                       attributes: List[int], 
                       side: str, 
                       thickness: float,
                       permittivity: float, 
                       permittivity_ma: float, 
                       permittivity_ms: float,
                       permittivity_sa: float, 
                       loss_tan: float, 
                       elements: List[Dict[str, Union[List[int], str]]]):
        """
        Add a dielectric boundary condition.

        Parameters:
            index (int): Index of this lossy dielectric interface, used in postprocessing output files.
            attributes (List[int]): Integer array of mesh boundary attributes for this lossy dielectric interface.
                If the interface consists of multiple elements with different "Side" values, use the "Elements" array described below.
            side (str): Defines the postprocessing side when this dielectric interface is an internal boundary surface.
                The available options are: "+X", "-X", "+Y", "-Y", "+Z", "-Z".
                If the boundary is not axis-aligned, the field value is taken from the side which is oriented along the specified direction.
                If no "Side" is specified, the field solution is taken from the neighboring element with the smaller electrical permittivity,
                which is an attempt to get the field in the domain corresponding to vacuum.
                If the interface consists of multiple elements with different "Side" values, use the "Elements" array described below.
            thickness (float): Thickness of this dielectric interface, specified in mesh length units.
            permittivity (Optional[float]): Relative permittivity for this dielectric interface.
                Leads to the general quality factor calculation without assuming the interface is a specific metal-air (MA),
                metal-substrate (MS), or substrate-air (SA) interface.
                None of "PermittivityMA", "PermittivityMS", or "PermittivitySA" should be specified when this value is given.
            permittivity_ma (Optional[float]): Relative permittivity for this dielectric interface assuming it is a metal-air (MA) interface.
                None of "PermittivityMS", "PermittivitySA", or the general "Permittivity" should be specified when this value is given.
            permittivity_ms (Optional[float]): Relative permittivity for this dielectric interface assuming it is a metal-substrate (MS) interface.
                None of "PermittivityMA", "PermittivitySA", or the general "Permittivity" should be specified when this value is given.
            permittivity_sa (Optional[float]): Relative permittivity for this dielectric interface assuming it is a substrate-air (SA) interface.
                None of "PermittivityMA", "PermittivityMS", or the general "Permittivity" should be specified when this value is given.
            loss_tan (float): Loss tangent for this lossy dielectric interface. Default: 0.0.
            elements (Optional[List[Dict[str, Union[List[int], str]]]]): This option should not be combined with the "Attributes" field described above.
                In the case where a single dielectric interface is made up of contributions with their own unique integer arrays of mesh boundary attributes,
                they can be specified here.

        """
        package = Dict(
            Index=index,
            Attributes=attributes,
            Side=side,
            Thickness=thickness,
            Permittivity=permittivity,
            PermittivityMA=permittivity_ma,
            PermittivityMS=permittivity_ms,
            PermittivitySA=permittivity_sa,
            LossTan=loss_tan,
            Elements=elements
        )
        self.Boundaries.setdefault("Dielectric", []).append(package)

    ##### self.Solver #####
    def add_eigenmode_solver(self,
                             target: list[int],
                             tol: float,
                             max_its: int,
                             N: int,
                             save: int,
                             solver_type: str,
                             contour_target_upper: float,
                             contour_aspect_ratio: float,
                             contour_n_points: float,
                             order: int):
        """
        Add an eigenmode solver.

        Args:
            target (float, optional): Nonzero frequency target above which to search for eigenvalues, in GHz.
            tol (float, optional): Relative convergence tolerance for the eigenvalue solver. Defaults to 1.0e-6.
            max_its (int, optional): Maximum number of iterations for the iterative eigenvalue solver. A value less than 1 uses the solver default.
            N (int, optional): Number of eigenvalues to compute. Defaults to 1.
            save (int, optional): Number of computed field modes to save to disk for visualization with ParaView. Files are saved in the paraview/ directory under the directory specified by config["Problem"]["Output"]. Defaults to 0.
            solver_type (str, optional): Specifies the eigenvalue solver to be used in computing the given number of eigenmodes of the problem. The available options are:
                - "SLEPc"
                - "ARPACK"
                - "FEAST"
                - "Default": Use the default eigensolver. Currently, this is the Krylov-Schur eigenvalue solver from "SLEPc".
            contour_target_upper (float, optional): Specifies the upper frequency target of the contour used for the FEAST eigenvalue solver, in GHz. This option is relevant only for type: "FEAST".
            contour_aspect_ratio (float, optional): Specifies the aspect ratio of the contour used for the FEAST eigenvalue solver. This should be greater than zero, where the aspect ratio is the ratio of the contour width to the frequency range ("contour_target_upper" - "target"). This option is relevant only for type: "FEAST".
            contour_n_points (int, optional): Number of contour integration points used for the FEAST eigenvalue solver. This option is relevant only for type: "FEAST".
            order (int): Finite element order (degree). Arbitrary high-order spaces are supported. 
        """
        package = dict(
            Target=target,
            Tol=tol,
            MaxIts=max_its,
            MaxSize=max_size,
            N=N,
            Save=save,
            Type=solver_type,
            ContourTargetUpper=contour_target_upper,
            ContourAspectRatio=contour_aspect_ratio,
            ContourNPoints=contour_n_points
        )
        self.Solver = dict(Eigenmode=package,
                           Order=order)
        self.problem_type = 'Eigenmode'

    def create_driven_config(
        min_freq: float,
        max_freq: float,
        freq_step: float,
        save_step: int,
        save_only_ports: bool,
        adaptive_tol: float,
        adaptive_max_samples: int,
        adaptive_max_candidates: int,
        restart: int,
        order: int) -> dict:
        """
        Create a configuration dictionary for the "Driven" simulation type.

        Args:
            min_freq (float): Minimum frequency for the simulation, in Hz.
            max_freq (float): Maximum frequency for the simulation, in Hz.
            freq_step (float): Frequency step size, in Hz.
            save_step (int): Frequency step at which to save results, in number of steps.
            save_only_ports (bool): Flag indicating whether to save results only for ports.
            adaptive_tol (float): Tolerance for adaptive sampling.
            adaptive_max_samples (int): Maximum number of samples for adaptive sampling.
            adaptive_max_candidates (int): Maximum number of candidates for adaptive sampling.
            restart (int): Number of restarts for the adaptive solver.
            order (int): Finite element order (degree). Arbitrary high-order spaces are supported.
        """
        package = {
            "MinFreq": min_freq,
            "MaxFreq": max_freq,
            "FreqStep": freq_step,
            "SaveStep": save_step,
            "SaveOnlyPorts": save_only_ports,
            "AdaptiveTol": adaptive_tol,
            "AdaptiveMaxSamples": adaptive_max_samples,
            "AdaptiveMaxCandidates": adaptive_max_candidates,
            "Restart": restart
        }

        self.Problem = dict(Driven = package,
                            Order = order)
        self.problem_type = 'Driven'


    ##### Write config to json #####
    def write_config_json(self, filename: str, sim_dir: str):
        """Write the config.json file for Palace to
        provide the simulation setup.

        Args:
            filename (str): Filename for the JSON.
            sim_dir (str): Directory for storing all the simulation data.
        """
        if not os.path.exists(sim_dir):
            os.mkdir(sim_dir)

        config_path = os.path.join(sim_dir, "PALACESOLVER_CONFIG.json")
        config_json_data = json.dumps(self.config)
        with open(config_path, "w") as config_file:
            config_file.write(config_json_data)
            config_file.close()