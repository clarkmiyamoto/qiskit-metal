import json
import os
from collections import OrderedDict

from qiskit_metal import Dict
from qiskit_metal.renderers.renderer_palace.palace_materials import PalaceMaterial 

class PalaceRunner:
    """Class for generating the config file (JSON) for Palace to run the simulation.
    """

    __supported_problem_type__ = ["Eigenmode", 
                                  "Driven", 
                                  "Transient", 
                                  "Electrostatic", 
                                  "Magnetostatic"]

    __supported_boundary_conditions__ = ["PEC",
                                         "Impedance",
                                         "Absorbing",
                                         "Conductivity",
                                         "LumpedPort",
                                         "WavePort",
                                         "WavePortPEC",
                                         "SurfaceCurrent",
                                         "Ground",
                                         "ZeroCharge",
                                         "Terminal"]
    

    def __init__(self):
        self.Problem = Dict()
        self.Model = Dict()
        self.Domains = Dict()
        self.Boundaries = Dict()
        self.Solver = Dict()
        self._config = Dict()
        self._materials = OrderedDict()
    
    @property
    def config(self):
        self._config = Dict(Problem=self.Problem,
                            Model=self.Model,
                            Domains=self.Domains,
                            Boundaries=self.Boundaries,
                            Solver=self.Solver)
        return self._config


    ##### self.Problem #####
    ## self.Problem.Type ##
    @property
    def problem_type(self):
        return self.Problem.Type
    
    @problem_type.setter
    def problem_type(self, problem_type: str):
        """Add supported simulation type.
        
        Args:
            problem_type (str): Simulation type. Accepted values are in self.__supported_problem_type__.
        """
        if problem_type in self.__supported_problem_type__:
            self.Problem.Type = problem_type
        else:
            raise ValueError(f"problem_type must be one of the following: {self.__supported_problem_type__}")
    
    ## self.Problem.Verbose ##
    @property
    def log_verboseness(self):
        return self.Problem.Verbose
    
    @log_verboseness.setter
    def log_verboseness(self, value: int):
        """Set printing log verboseness

        Args:
            value (int): Printing log verboseness.
        """
        self.Problem.Verbose = int(value)

    ## self.Problem.Output ##
    @property
    def output_path(self, path: str):
        return self.Problem.Output
    
    @output_path.setter
    def output_path(self, output_path: str):
        """Set path of output files from simulation
        """
        self.Problem.Output = str(output_path)


    ##### self.Model #####
    ## self.Model.Mesh ##
    @property
    def mesh_path(self):
        return self.Model.Mesh
    
    @mesh_path.setter
    def mesh_path(self, path: str):
        """Set path to mesh generated by GMSH, absolute path is recommended."""
        self.Model.Mesh = str(path)

    ##### self.Domains #####
    @property
    def materials(self):
        return self._materials

    def update_material(self, 
                     name: str, 
                     attributes: List(int), 
                     permeability: float, 
                     permittivity: float, 
                     loss_tan: float, 
                     conductivity: float, 
                     london_depth: float, 
                     material_axes: list):
        """Method to add a new material / update existing materials.
        """
        palace_material = PalaceMaterial(name, 
                                  attributes, 
                                  permeability, 
                                  permittivity, 
                                  loss_tan, 
                                  conductivity, 
                                  london_depth, 
                                  material_axes)
        package = palace_material.dict_for_json()

        # Updates self.materials property
        self._materials[name] = palace_material

        # Updates self.Domains.Materials
        if name in self._materials:
            pos = list(self._materials.keys()).index(name)
            self.Domains.Materials[pos] = package
        else:
            self.Domains.setdefault("Materials", []).append(package)


    ##### self.Boundaries #####
    def add_pec(self, attributes: List(int)):
        """Add a Perfect Electrical Conductor (PEC) boundary condition)"""
        self.Boundaries.setdefault("PEC", {"Attributes": []})["Attributes"] += attributes

    
    def add_conductivity(self, 
                         attributes: List(int), 
                         conductivity: float,
                         permeability: float,
                         thickness: float = None):
        """
        Add a Conductor boundary condition
        
        Args:
            attributes (List(int)): Integer array of mesh boundary attributes for this finite conductivity boundary.
            conductivity (float): Electrical conductivity for this finite conductivity boundary, S/m.
            permeability (float): Relative permeability for this finite conductivity boundary.
            thickness (float, optional): Conductor thickness for this finite conductivity boundary specified in mesh length units. 
                                         Activates a finite conductivity boundary condition which accounts for nonzero metal thickness.
                                         Defaults to infinitesimally thin. 
        """
        package = Dict(Attributes=attributes,
                       Conductivity=conductivity,
                       Permeability=permeability,
                       Thickness=thickness)

        self.Boundaries.setdefault("Conductivity", []).append(package)

    def add_lumped_port(self, 
                        index: int,
                        attributes: List(int),
                        direction: str,
                        excitation: bool,
                        R: float = 0.0,
                        L: float = 0.0,
                        C: float = 0.0,
                        per_square: bool = False):
        """
        Add a Lumped Port boundary condition.

        Args:
            Index (int): Index of this lumped port, used in postprocessing output files.
            Attributes (List(int)): Integer array of mesh boundary attributes for this lumped port boundary. 
                            If this port is to be a multielement lumped port with more than a single lumped element, 
                            use the "Elements" array described below.
            Direction (str): Direction to define the polarization direction of the port field mode on this lumped port boundary. 
                            Lumped ports must be axis-aligned unless the port is a coaxial port. 
                            The available options are: "+X", "-X", "+Y", "-Y", "+Z", "-Z", "+R", "-R" ("R" is for a coaxial lumped port). 
                            If this port is to be a multielement lumped port with more than a 
                            single lumped element, use the "Elements" array described below.
            Excitation (bool): Turns on or off port excitation for this lumped port boundary for driven or transient simulation types.
            R (float, optional): Circuit resistance used for computing this lumped port boundary's impedance, Ω. Defaults to 0 Ω.
            L (float, optional): Circuit inductance used for computing this lumped port boundary's impedance, H. Defaults to 0 H.
            C (float, optional): Circuit capacitance used for computing this lumped port boundary's impedance, F. Defaults to 0 F.
            per_square (bool, optional): Change `R`, `L`, `C` units to unit / sq. Defaults to false (off).
        """
        # Check for valid directions
        supported_directions = ["+X", "-X", "+Y", "-Y", "+Z", "-Z", "+R", "-R"]
        if direction not in supported_directions:
            raise ValueError(f'direction must be one of the following: {supported_directions}')
        
        # Begin applying Lumped Port
        package = Dict(Index=index,
                       Attributes=attributes,
                       Direction=direction,
                       Excitation=excitation)
        # Check wether units are in per_square or not.
        if (bool(per_square) == False):
            package['R'] = R
            package['L'] = L
            package['C'] = C
        else:
            package['Rs'] = R
            package['Ls'] = L
            package['Cs'] = C
        
        self.Boundaries.setdefault("LumpedPort", []).append(package)

    def add_ground(self, attributes: List(int)):
        self.Boundaries.setdefault("Ground", {"Attributes": []})["Attributes"] += attributes

    def add_dielectric(self, 
                       index: int, 
                       attributes: List[int], 
                       side: str, 
                       thickness: float,
                       permittivity: float, 
                       permittivity_ma: float, 
                       permittivity_ms: float,
                       permittivity_sa: float, 
                       loss_tan: float, 
                       elements: List[Dict[str, Union[List[int], str]]]):
        """
        Add a dielectric boundary condition.

        Parameters:
            index (int): Index of this lossy dielectric interface, used in postprocessing output files.
            attributes (List[int]): Integer array of mesh boundary attributes for this lossy dielectric interface.
                If the interface consists of multiple elements with different "Side" values, use the "Elements" array described below.
            side (str): Defines the postprocessing side when this dielectric interface is an internal boundary surface.
                The available options are: "+X", "-X", "+Y", "-Y", "+Z", "-Z".
                If the boundary is not axis-aligned, the field value is taken from the side which is oriented along the specified direction.
                If no "Side" is specified, the field solution is taken from the neighboring element with the smaller electrical permittivity,
                which is an attempt to get the field in the domain corresponding to vacuum.
                If the interface consists of multiple elements with different "Side" values, use the "Elements" array described below.
            thickness (float): Thickness of this dielectric interface, specified in mesh length units.
            permittivity (Optional[float]): Relative permittivity for this dielectric interface.
                Leads to the general quality factor calculation without assuming the interface is a specific metal-air (MA),
                metal-substrate (MS), or substrate-air (SA) interface.
                None of "PermittivityMA", "PermittivityMS", or "PermittivitySA" should be specified when this value is given.
            permittivity_ma (Optional[float]): Relative permittivity for this dielectric interface assuming it is a metal-air (MA) interface.
                None of "PermittivityMS", "PermittivitySA", or the general "Permittivity" should be specified when this value is given.
            permittivity_ms (Optional[float]): Relative permittivity for this dielectric interface assuming it is a metal-substrate (MS) interface.
                None of "PermittivityMA", "PermittivitySA", or the general "Permittivity" should be specified when this value is given.
            permittivity_sa (Optional[float]): Relative permittivity for this dielectric interface assuming it is a substrate-air (SA) interface.
                None of "PermittivityMA", "PermittivityMS", or the general "Permittivity" should be specified when this value is given.
            loss_tan (float): Loss tangent for this lossy dielectric interface. Default: 0.0.
            elements (Optional[List[Dict[str, Union[List[int], str]]]]): This option should not be combined with the "Attributes" field described above.
                In the case where a single dielectric interface is made up of contributions with their own unique integer arrays of mesh boundary attributes,
                they can be specified here.

        """
        package = {
            "Index": index,
            "Attributes": attributes,
            "Side": side,
            "Thickness": thickness,
            "Permittivity": permittivity,
            "PermittivityMA": permittivity_ma,
            "PermittivityMS": permittivity_ms,
            "PermittivitySA": permittivity_sa,
            "LossTan": loss_tan,
            "Elements": elements
        }

        self.Boundaries.setdefault("Dielectric", []).append(package)



        

    def write_config_json(self, filename: str, sim_dir: str):
        """Write the config.json file for Palace to
        provide the simulation setup.

        Args:
            filename (str): Filename for the JSON.
            sim_dir (str): Directory for storing all the simulation data.
        """
        if not os.path.exists(sim_dir):
            os.mkdir(sim_dir)

        config_path = os.path.join(sim_dir, "PALACESOLVER_CONFIG.json")
        config_json_data = json.dumps(self.config)
        with open(config_path, "w") as config_file:
            config_file.write(config_json_data)
            config_file.close()